msgid ""
msgstr ""
"Project-Id-Version: The Chester Programming Language\n"
"POT-Creation-Date: 2024-09-27T22:51:36+12:00\n"
"PO-Revision-Date: 2024-09-24 17:37+1200\n"
"Last-Translator:  <email@address.com>\n"
"Language-Team: Language zh-TW\n"
"Language: zh-TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1
msgid "https://github.com/rust-lang-nursery/mdBook/issues/677"
msgstr ""

#: src/SUMMARY.md:2 src/chapter_1.md:1
msgid "Chapter 1: Introduction to Chester"
msgstr ""

#: src/SUMMARY.md:3 src/chapter_2.md:1
msgid "Chapter 2: Statements"
msgstr ""

#: src/chapter_1.md:3
msgid ""
"Welcome to the Chester Programming Language documentation! Chester is a "
"modern, expressive language designed to combine the best features of "
"functional and object-oriented programming paradigms."
msgstr ""
"Chester æ˜¯ä¸€ç¨®ç¾ä»£ã€è¡¨é”åŠ›å¼·çš„ç¨‹å¼èªè¨€ï¼Œçµåˆäº†å‡½æ•¸å¼å’Œç‰©ä»¶å°å‘ç¨‹å¼è¨­è¨ˆçš„å„ª"
"é»ã€‚"

#: src/chapter_1.md:5
msgid "What is Chester?"
msgstr "Chester æ˜¯ä»€éº¼ï¼Ÿ"

#: src/chapter_1.md:7
msgid ""
"Chester is a statically-typed language that aims to provide a balance "
"between expressiveness and safety. It draws inspiration from languages like "
"Scala, Haskell, and Rust, while introducing its own unique features."
msgstr ""
"Chester æ˜¯ä¸€ç¨®éœæ…‹é¡å‹èªè¨€ï¼Œæ—¨åœ¨æä¾›è¡¨é”åŠ›å’Œå®‰å…¨æ€§çš„å¹³è¡¡ã€‚å®ƒå¾åƒ Scalaã€"
"Haskell å’Œ Rust çš„èªè¨€ä¸­æ±²å–éˆæ„Ÿï¼ŒåŒæ™‚å¼•å…¥äº†è‡ªå·±çš„ç¨ç‰¹åŠŸèƒ½ã€‚"

#: src/chapter_1.md:9
msgid "Some key characteristics of Chester include:"
msgstr "Chester çš„ä¸€äº›é—œéµç‰¹æ€§åŒ…æ‹¬ï¼š"

#: src/chapter_1.md:11
msgid "Strong type system with type inference"
msgstr "å¼·å¤§çš„é¡å‹ç³»çµ±å’Œé¡å‹æ¨æ–·"

#: src/chapter_1.md:12
msgid "Support for both functional and object-oriented programming styles"
msgstr "æ”¯æ´å‡½æ•¸å¼å’Œç‰©ä»¶å°å‘ç¨‹å¼è¨­è¨ˆé¢¨æ ¼"

#: src/chapter_1.md:13
msgid "Pattern matching and algebraic data types"
msgstr "æ¨¡å¼åŒ¹é…å’Œä»£æ•¸æ•¸æ“šé¡å‹"

#: src/chapter_1.md:14
msgid "Effect system for managing side effects"
msgstr "æ•ˆæœç³»çµ±ç”¨æ–¼ç®¡ç†å‰¯ä½œç”¨"

#: src/chapter_1.md:15
msgid "Unicode support, allowing for expressive identifiers"
msgstr "Unicode æ”¯æ´ï¼Œå…è¨±è¡¨é”æ€§è­˜åˆ¥ç¬¦"

#: src/chapter_1.md:17
msgid "A Glimpse of Chester"
msgstr "Chester çš„ä¸€ç¥"

#: src/chapter_1.md:19
msgid ""
"Let's take a look at a simple Chester program to get a feel for the language:"
msgstr "è®“æˆ‘å€‘çœ‹çœ‹ä¸€å€‹ç°¡å–®çš„ Chester ç¨‹å¼ä¾†æ„Ÿå—ä¸€ä¸‹é€™ç¨®èªè¨€ï¼š"

#: src/chapter_1.md:21
msgid ""
"```chester\n"
"module ğŸ˜¿ğŸ˜¿;\n"
"\n"
"def me: String = \"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ»ã‚¨ãƒ³ã‚¸ã‚§ãƒ«\";\n"
"```"
msgstr ""

#: src/chapter_2.md:3
msgid "Scope of `let` and `def`"
msgstr "let å’Œ def çš„ç¯„åœ"

#: src/chapter_2.md:5
msgid ""
"In Chester, `let` and `def` are used to declare bindings, but they differ in "
"how they handle scoping and forward references. Understanding these "
"differences is crucial for writing correct and efficient Chester programs."
msgstr ""
"åœ¨ Chester ä¸­ï¼Œlet å’Œ def ç”¨æ–¼å®£å‘Šç¹«çµï¼Œä½†å®ƒå€‘åœ¨è™•ç†ç¯„åœå’Œå‰å‘å¼•ç”¨æ™‚æœ‰æ‰€ä¸åŒã€‚"
"äº†è§£é€™äº›å·®ç•°å°æ–¼æ’°å¯«æ­£ç¢ºä¸”é«˜æ•ˆçš„ Chester ç¨‹å¼è‡³é—œé‡è¦ã€‚"

#: src/chapter_2.md:7
msgid "`let` Bindings"
msgstr "let ç¹«çµ"

#: src/chapter_2.md:9
msgid ""
"**Local Scope**: `let` bindings are only visible **after** their declaration "
"within the current block."
msgstr ""
"**å€åŸŸç¯„åœ**ï¼šlet ç¹«çµåƒ…åœ¨å®£å‘Šå¾Œåœ¨ç•¶å‰å¡Šä¸­å¯è¦‹ã€‚"

#: src/chapter_2.md:10
msgid ""
"**No Forward References**: You cannot reference a `let` binding before it's "
"declared."
msgstr ""
"**ä¸å…è¨±å‰å‘å¼•ç”¨**ï¼šä½ ä¸èƒ½åœ¨å®£å‘Šä¹‹å‰å¼•ç”¨ let ç¹«çµã€‚"

#: src/chapter_2.md:11
msgid ""
"**Type Inference**: If no type annotation is provided, the compiler infers "
"the type from the binding's body."
msgstr ""
"**é¡å‹æ¨æ–·**ï¼šå¦‚æœæ²’æœ‰æä¾›é¡å‹è¨»è§£ï¼Œç·¨è­¯å™¨æœƒå¾ç¹«çµçš„ä¸»é«”æ¨æ–·é¡å‹ã€‚"

#: src/chapter_2.md:13 src/chapter_2.md:33
msgid "**Example:**"
msgstr ""
"**ç¯„ä¾‹**ï¼š"

#: src/chapter_2.md:15
msgid ""
"```chester,playground,editable\n"
"// Correct usage of 'let'\n"
"let x = 5;\n"
"let y = x; // 'x' is defined before use\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"// æ­£ç¢ºä½¿ç”¨ let\n"
"let x = 5;\n"
"let y = x; // 'x' åœ¨ä½¿ç”¨å‰å·²å®šç¾©\n"
"```"

#: src/chapter_2.md:21
msgid ""
"```chester,playground,editable\n"
"// Incorrect usage of 'let'\n"
"let y = x + 2; // Error: 'x' is not defined yet\n"
"let x = 5;\n"
"```"
msgstr ""

#: src/chapter_2.md:27
msgid "`def` Bindings"
msgstr ""

#: src/chapter_2.md:29
msgid ""
"**Global Scope**: `def` bindings are visible throughout the entire block, "
"even before their declaration."
msgstr ""
"**å…¨åŸŸç¯„åœ**ï¼šdef ç¹«çµåœ¨æ•´å€‹å¡Šä¸­å¯è¦‹ï¼Œç”šè‡³åœ¨å®£å‘Šä¹‹å‰ã€‚"

#: src/chapter_2.md:30
msgid ""
"**Allows Forward References**: You can reference a `def` binding before it's "
"declared."
msgstr ""
"**å…è¨±å‰å‘å¼•ç”¨**ï¼šä½ å¯ä»¥åœ¨å®£å‘Šä¹‹å‰å¼•ç”¨ def ç¹«çµã€‚"

#: src/chapter_2.md:31
msgid ""
"**Type Annotation Required for Forward References**: If you use a `def` "
"binding before its declaration, you must provide a type annotation."
msgstr ""
"**éœ€è¦é¡å‹è¨»è§£**ï¼šå¦‚æœä½ åœ¨å®£å‘Šä¹‹å‰ä½¿ç”¨ def ç¹«çµï¼Œå¿…é ˆæä¾›é¡å‹è¨»è§£ã€‚"

#: src/chapter_2.md:35
msgid ""
"```chester,playground,editable\n"
"// Correct usage of 'def' with type annotation\n"
"def y = square(5); // 'square' is used before its declaration\n"
"\n"
"def square(n: Int) = n * n; // Type annotation for 'n' is required\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"// æ­£ç¢ºä½¿ç”¨ def ä¸¦æä¾›é¡å‹è¨»è§£\n"
"def y = square(5); // 'square' åœ¨ä½¿ç”¨å‰å·²å®£å‘Š\n"
"\n"
"def square(n: Int) = n * n; // éœ€è¦é¡å‹è¨»è§£\n"
"```"

#: src/chapter_2.md:42
msgid ""
"```chester,playground,editable\n"
"// Incorrect usage of 'def' without type annotation\n"
"def y = increment(5); // 'increment' is used before its declaration\n"
"\n"
"def increment(n) = n + 1; // Error: Missing type annotation for 'n'\n"
"```"
msgstr ""

#: src/chapter_2.md:49
msgid "Summary of Scoping Rules"
msgstr ""

#: src/chapter_2.md:51
msgid "**`let` Bindings**:"
msgstr ""

#: src/chapter_2.md:52
msgid "Visible only after their declaration within the current block."
msgstr ""

#: src/chapter_2.md:53
msgid "Do **not** allow forward references."
msgstr ""

#: src/chapter_2.md:54
msgid "Type annotations are optional if the type can be inferred."
msgstr ""

#: src/chapter_2.md:56
msgid "**`def` Bindings**:"
msgstr ""

#: src/chapter_2.md:57
msgid "Visible throughout the entire block."
msgstr ""

#: src/chapter_2.md:58
msgid "Allow forward references."
msgstr ""

#: src/chapter_2.md:59
msgid "Require type annotations when used before their declarations."
msgstr ""

#: src/chapter_2.md:61
msgid "Compiler Behavior"
msgstr ""

#: src/chapter_2.md:63
msgid ""
"When processing a block, the Chester compiler handles `let` and `def` "
"bindings differently to manage scope and type checking."
msgstr ""

#: src/chapter_2.md:65
msgid "Processing `def` Bindings"
msgstr ""

#: src/chapter_2.md:67
msgid "**Collection Phase**:"
msgstr ""

#: src/chapter_2.md:68
msgid ""
"The compiler collects all `def` bindings, noting their names, type "
"annotations, and identifiers."
msgstr ""

#: src/chapter_2.md:69
msgid "It tracks forward references to detect usages before declarations."
msgstr ""

#: src/chapter_2.md:71
msgid "**Type Annotation Checks**:"
msgstr ""

#: src/chapter_2.md:72
msgid ""
"For forward-referenced `def` bindings without type annotations, the compiler "
"reports a `MissingTypeAnnotationError`."
msgstr ""

#: src/chapter_2.md:74
msgid "**Context Updates**:"
msgstr ""

#: src/chapter_2.md:75
msgid ""
"The compiler adds placeholders or inferred types to the context, allowing "
"forward-referenced `def` bindings to be used."
msgstr ""

#: src/chapter_2.md:77
msgid "Processing `let` Bindings"
msgstr ""

#: src/chapter_2.md:79
msgid "**Sequential Processing**:"
msgstr ""

#: src/chapter_2.md:80
msgid "`let` bindings are processed in order of their appearance."
msgstr ""

#: src/chapter_2.md:81
msgid "Each `let` binding is added to the context **after** its declaration."
msgstr ""

#: src/chapter_2.md:82
msgid "**No Forward References**:"
msgstr ""

#: src/chapter_2.md:83
msgid "Referencing a `let` binding before its declaration results in an error."
msgstr ""

#: src/chapter_2.md:85
msgid "Best Practices"
msgstr ""

#: src/chapter_2.md:87
msgid ""
"Use `let` when you don't need to reference the binding before its "
"declaration."
msgstr ""

#: src/chapter_2.md:88
msgid ""
"Use `def` when you need forward references or are defining recursive "
"functions."
msgstr ""

#: src/chapter_2.md:89
msgid ""
"Always provide type annotations for `def` bindings that are forward-"
"referenced to avoid compilation errors."
msgstr ""

#: src/chapter_2.md:91
msgid ""
"By understanding these scoping rules, you can write more predictable and "
"maintainable Chester code."
msgstr ""
